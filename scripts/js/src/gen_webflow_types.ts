// Generates the webflow_types.ts based on the collection information returned via API.

import Webflow from 'webflow-api';
import { compile } from 'json-schema-to-typescript';
import { program } from '@commander-js/extra-typings';
import fs from 'node:fs/promises';
import assert from 'node:assert';
import util from 'util';


const prog = program
    .argument('<output-file>', 'Path to output TS file to generate.')
    .parse();
const [outputFile] = prog.processedArgs;

if (!process.env.WEBFLOW_COLLECTION_ID || !process.env.WEBFLOW_API_TOKEN) {
    console.error('Missing WEBFLOW_COLLECTION_ID or WEBFLOW_API_TOKEN');
    process.exit(1);
}
const webflow = new Webflow({ token: process.env.WEBFLOW_API_TOKEN });
const mapsCollectionId = process.env.WEBFLOW_COLLECTION_ID;

const mapsCollection = await webflow.collection({ collectionId: mapsCollectionId });
console.log(util.inspect(mapsCollection, { showHidden: false, depth: null, colors: true }))

const schema: any = {
    '$schema': 'https://json-schema.org/draft/2020-12/schema',
    '$defs': {
        mapFieldsRead: {
            title: 'WebflowMapFieldsRead',
            type: 'object',
            properties: {},
            required: [],
            additionalProperties: false,
        },
        mapFieldsWrite: {
            title: 'WebflowMapFieldsWrite',
            type: 'object',
            properties: {},
            required: [],
            additionalProperties: false,
        },
        imageRef: {
            title: 'WebflowImageRef',
            type: 'object',
            properties: {
                fileId: { type: 'string' },
                url: { type: 'string' },
                alt: { type: 'string' },
            },
            required: ['fileId', 'url'],
            additionalProperties: false,
        }
    }
}
const schemaRead = schema['$defs']['mapFieldsRead'];
const schemaWrite = schema['$defs']['mapFieldsWrite'];

for (const field of mapsCollection.fields) {
    const desc: any = {};
    if ('helpText' in field) {
        desc.description = field.helpText;
    }
    let propsRead: any;
    let propsWrite: any;
    switch (field.type) {
        case 'PlainText':
        case 'RichText':
        case 'Date':
        case 'Link':
        case 'User':
            propsRead = propsWrite = { type: 'string', ...desc };
            break;
        case 'Bool':
            propsRead = propsWrite = { type: 'boolean', ...desc };
            break;
        case 'ImageRef':
            propsRead = { '$ref': '#/$defs/imageRef' };
            propsWrite = { type: 'string', ...desc };
            break;
        case 'Number':
            propsRead = propsWrite = { type: 'number', ...desc };
            break;
        case 'Set':
            assert((field as any).innerType === 'ImageRef');
            propsRead = { type: 'array', items: { '$ref': '#/$defs/imageRef' } };
            propsWrite = { type: 'array', items: { type: 'string' } };
            break;
        case 'ItemRefSet':
            propsRead = propsWrite = { type: 'array', items: { type: 'string' }, ...desc };
            break;
        default:
            throw new Error(`Unknown field type: ${field.type}`);
    }

    schemaRead.properties[field.slug] = propsRead;
    if (field.required) {
        schemaRead.required.push(field.slug);
    }

    const ignoreForWrite = [
        'created-on', 'updated-on', 'published-on',
        'created-by', 'updated-by', 'published-by'
    ];
    if (!ignoreForWrite.includes(field.slug)) {
        schemaWrite.properties[field.slug] = propsWrite;
        if (field.required) {
            schemaWrite.required.push(field.slug);
        }
    }

}

const ts = await compile(schema, '', {
    unreachableDefinitions: true,
    bannerComment: `/* eslint-disable */
/**
 * This file was automatically generated by gen_webflow_types.ts.
 * DO NOT MODIFY IT BY HAND. Instead, run make refresh_webflow_types
 */
`
});
await fs.writeFile(outputFile, ts);
